import jwt from "jsonwebtoken";
import { AccountBalanceQuery, Client } from "@hashgraph/sdk";
import dotenv from "dotenv";
import bcrypt from "bcrypt";
import { Op } from "sequelize";
import User from "../models/User.js";
import Profiles from "../models/Profile.js";
import Streams from "../models/Stream.js";
import Follower from "../models/Follower.js";
// import BlacklistedToken from "../models/BlacklistedToken.js";

dotenv.config();

const client = Client.forTestnet();

// Utility function to validate Hedera Account ID
const validateHederaAccountId = (accountId) => {
  const hederaAccountRegex = /^\d+\.\d+\.\d+$/;
  return hederaAccountRegex.test(accountId);
};

const AccountController = {
  async loginOrRegister(req, res) {

    try {
      const { accountId, publicKey } = req.body;

      if (!accountId || !publicKey) {
        return res.status(400).json({
          success: false,
          message: "Please provide accountId and publicKey",
          required: ["accountId", "publicKey"],
        });
      }

      if (!validateHederaAccountId(accountId)) {
        console.log("‚ùå Invalid Hedera Account ID format:", accountId);
        return res.status(400).json({
          success: false,
          message: "Invalid Hedera Account ID format",
          expected: "Format: 0.0.123456",
        });
      }

      console.log("üîç Finding user...");
      let user = await User.findOne({
        where: { hederaAccountId: accountId },
      });

      // If user doesn't exist, create new user (auto-register)
      if (!user) {
        console.log("üë§ User not found, creating new user...");

        // Generate a default username (optional, bisa juga null)
        const defaultUsername = `user_${accountId.replace(/\./g, "_")}`;

        user = await User.create({
          hederaAccountId: accountId,
          hederaPublicKey: publicKey,
          username: defaultUsername, // Auto-generated, user can change later
          created_at: new Date(),
          updated_at: new Date(),
        });

        console.log("‚úÖ New user created:", user.id);
      } else {
        console.log("‚úÖ Existing user found:", user.id);

        // Optional: Update public key if it's different
        if (user.hederaPublicKey !== publicKey) {
          await user.update({
            hederaPublicKey: publicKey,
            updated_at: new Date(),
          });
          console.log("üîÑ Public key updated");
        }
      }

      // Create JWT token with user ID
      const token = jwt.sign(
        {
          id: user.user_id,
          accountId: user.hederaAccountId,
        },
        process.env.JWT_SECRET,
        { expiresIn: "1h" }
      );

      console.log("‚úÖ Authentication successful:", user.id);

      return res.status(200).json({
        success: true,
        message:
          user.created_at.getTime() === user.updated_at.getTime()
            ? "User registered and logged in successfully"
            : "User logged in successfully",
        token,
        user: {
          id: user.id,
          accountId: user.hederaAccountId,
          username: user.username,
          created_at: user.created_at,
        },
        isNewUser: user.created_at.getTime() === user.updated_at.getTime(),
      });
    } catch (error) {
      console.error("‚ùå LoginOrRegister error:", error);

      if (error.name === "SequelizeValidationError") {
        return res.status(400).json({
          success: false,
          message: "Validation error",
          errors: error.errors.map((e) => ({
            field: e.path,
            message: e.message,
          })),
        });
      }

      if (error.name === "SequelizeUniqueConstraintError") {
        return res.status(409).json({
          success: false,
          message: "Account ID already exists with different data",
        });
      }

      return res.status(500).json({
        success: false,
        message: "Internal server error",
        error:
          process.env.NODE_ENV === "development"
            ? error.message
            : "Something went wrong",
      });
    }
  },

  // Get user by ID
  async getUser(req, res) {
    console.log("üì• GetUser endpoint called");

    try {
      const { user_id } = req.params;

      // Validate user_id
      if (!user_id || isNaN(user_id)) {
        return res.status(400).json({
          success: false,
          message: "Valid user ID is required",
        });
      }

      // Find user by ID
      const user = await User.findByPk(user_id);
      if (!user) {
        return res.status(404).json({
          success: false,
          message: "User not found",
        });
      }

      return res.status(200).json({
        success: true,
        message: "User retrieved successfully",
        user: {
          id: user.id,
          username: user.username,
          accountId: user.hederaAccountId,
          created_at: user.created_at,
        },
      });
    } catch (error) {
      console.error("‚ùå Error in GetUser:", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error",
      });
    }
  },

  // Show user balance (Hedera account balance)
  async showUserBalance(req, res) {
    try {
      // Extract token from Authorization header
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return res.status(401).json({
          success: false,
          message: "No token provided or invalid format",
        });
      }

      const token = authHeader.split(" ")[1];

      // Verify and decode JWT
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      console.log("üîç Decoded token:", decoded);

      // Check if user ID exists in token
      if (!decoded.id) {
        return res.status(401).json({
          success: false,
          message: "Invalid token payload",
        });
      }

      // Find user by ID from token
      const user = await User.findByPk(decoded.id);
      if (!user) {
        return res.status(401).json({
          success: false,
          message: "User not found",
        });
      }

      console.log("üë§ User found:", user.hederaAccountId);

      // Get account balance from Hedera
      const accountBalance = await new AccountBalanceQuery()
        .setAccountId(user.hederaAccountId)
        .execute(client);

      console.log("üí∞ Balance fetched:", accountBalance.hbars.toString());

      return res.status(200).json({
        success: true,
        balance: accountBalance.hbars.toString(),
        user: {
          id: user.id,
          accountId: user.hederaAccountId,
          username: user.username,
        },
      });
    } catch (error) {
      console.error("‚ùå Error fetching balance:", error);

      // Handle JWT errors specifically
      if (error.name === "JsonWebTokenError") {
        return res.status(401).json({
          success: false,
          message: "Invalid token",
        });
      }

      if (error.name === "TokenExpiredError") {
        return res.status(401).json({
          success: false,
          message: "Token expired",
        });
      }

      return res.status(500).json({
        success: false,
        message: "Internal server error",
        error:
          process.env.NODE_ENV === "development"
            ? error.message
            : "Something went wrong",
      });
    }
  },

  // Show user hedera account id
  async showUserHederaAccountId(req, res) {
    try {
      const token = req.headers.authorization?.split(" ")[1];
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      const user = await User.findByPk(decoded.id, {
        attributes: ["username", "hederaAccountId"],
      });

      if (!user) return res.status(404).json({ message: "User not found" });

      res.status(200).json({
        username: user.username,
        hederaAccountId: user.hederaAccountId,
      });
    } catch (error) {
      console.error("‚ùå Error fetching account info:", error);
      res.status(500).json({ error: error.message });
    }
  },

  // Update profile picture (profile table)
  async updateProfilePicture(req, res) {
    try {
      const token = req.headers.authorization?.split(" ")[1];
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      const profile = await Profiles.findOne({
        where: { user_id: decoded.id },
      });

      if (!profile)
        return res.status(404).json({ message: "Profile not found" });

      const { profile_picture } = req.body;
      await profile.update({ profile_picture });

      res.status(200).json({ message: "Profile picture updated" });
    } catch (error) {
      console.error("‚ùå Error updating profile picture:", error);
      res.status(500).json({ error: error.message });
    }
  },

  // Update profile (profile table)
  async updateProfile(req, res) {
    try {
      const token = req.headers.authorization?.split(" ")[1];
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      const profile = await Profiles.findOne({
        where: { user_id: decoded.id },
      });

      if (!profile)
        return res.status(404).json({ message: "Profile not found" });

      const { full_name, bio, gender, date_of_birth } = req.body;
      await profile.update({ full_name, bio, gender, date_of_birth });

      res.status(200).json({ message: "Profile updated" });
    } catch (error) {
      console.error("‚ùå Error updating profile:", error);
      res.status(500).json({ error: error.message });
    }
  },

  // Show user name (profile table)
  async showUserName(req, res) {
    try {
      const token = req.headers.authorization?.split(" ")[1];
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      const profile = await Profiles.findOne({
        where: { user_id: decoded.id },
        attributes: ["full_name"],
      });

      if (!profile)
        return res.status(404).json({ message: "Profile not found" });

      res.status(200).json({ full_name: profile.full_name });
    } catch (error) {
      console.error("‚ùå Error fetching user name:", error);
      res.status(500).json({ error: error.message });
    }
  },

  // Get account details
  async getAccount(req, res) {
    try {
      const authHeader = req.headers["authorization"];
      const token = authHeader && authHeader.split(" ")[1];
      if (!token) {
        return res.status(401).json({ message: "Token required" });
      }

      jwt.verify(token, process.env.JWT_SECRET, async (err, decoded) => {
        if (err) return res.status(401).json({ message: "Invalid token" });

        const user = await User.findByPk(decoded.id, {
          include: [
            {
              model: Profiles,
              as: "profile",
              attributes: [
                "full_name",
                "bio",
                "gender",
                "date_of_birth",
                "profile_picture",
              ],
            },
            {
              model: Streams,
              as: "stream",
              attributes: [
                "title",
                "thumbnail",
                "stream_url",
                "is_live",
                "topic_id",
              ],
            },
          ],
          attributes: { exclude: ["password", "hederaPrivateKey"] },
        });

        if (!user) return res.status(404).json({ message: "User not found" });

        const followerCount = await Follower.count({
          where: { following_id: decoded.id },
        });

        user.dataValues.followerCount = followerCount;

        res.status(200).json(user);
      });
    } catch (error) {
      console.error("Get account error:", error);
      res.status(500).json({ message: error.message });
    }
  },

  // Logout method
  async logout(req, res) {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res
          .status(401)
          .json({ message: "Authorization header missing" });
      }

      const token = authHeader.split(" ")[1];
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      await BlacklistedToken.create({ token });
      return res.status(200).json({ message: "Logout successful" });
    } catch (error) {
      if (error.name === "JsonWebTokenError") {
        return res.status(401).json({ message: "Invalid token" });
      }
      console.error("Logout error:", error);
      res.status(500).json({ message: error.message });
    }
  },

  // Get all users (admin only)
  async getAllUsers(req, res) {
    console.log("üì• GetAllUsers endpoint called");

    try {
      const { page = 1, limit = 10, search } = req.query;
      const offset = (page - 1) * limit;

      let whereClause = {};
      if (search) {
        whereClause = {
          username: {
            [Op.iLike]: `%${search}%`,
          },
        };
      }

      const { count, rows: users } = await User.findAndCountAll({
        where: whereClause,
        limit: parseInt(limit),
        offset: parseInt(offset),
        order: [["created_at", "DESC"]],
        attributes: { exclude: ["password", "hederaPrivateKey"] },
      });

      return res.status(200).json({
        success: true,
        message: "Users retrieved successfully",
        data: {
          users: users.map((user) => ({
            id: user.id,
            username: user.username,
            hederaAccountId: user.hederaAccountId,
            created_at: user.created_at,
          })),
          pagination: {
            current_page: parseInt(page),
            total_pages: Math.ceil(count / limit),
            total_users: count,
            per_page: parseInt(limit),
          },
        },
      });
    } catch (error) {
      console.error("‚ùå Error in GetAllUsers:", error);
      return res.status(500).json({
        success: false,
        message: "Internal server error",
      });
    }
  },
};

export default AccountController;